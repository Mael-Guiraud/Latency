%\documentclass[a4paper,10pt]{article}
\documentclass[10pt, conference, letterpaper]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{url}
\usepackage{graphicx,graphics} 
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{longtable}
\usepackage{complexity}
\usepackage{tkz-graph}
\usepackage{float}
\usepackage{tabularx}
\usepackage{setspace}
\usepackage{icomma}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{authblk}
\usepackage[colorlinks=true,breaklinks=true,linkcolor=blue]{hyperref}


\newcommand\rmatching{${\cal R}$-matching\xspace}
\newcommand\mdelay{$\cal M$-delay\xspace}
\newcommand\matchedgraph{{\bf matched graph}}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}

\setlength{\parskip}{1ex} % Espace entre les paragraphes

\newtheorem{fact}{Fact}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}{Definition}
\newtheorem{corollary}{Corollary}

% \renewcommand{\thefootnote}{\*}

\newcommand{\todo}[1]{{\color{red} TODO: {#1}}}
\newcommand\pazl{\textsc{pazl}\xspace}
\newcommand\pall{\textsc{pall}\xspace}
\newcommand\bra{\textsc{bra}\xspace}
\newcommand\pra{\textsc{pra}\xspace}
\newcommand\minpra{\textsc{min-pra}\xspace}
%opening
\title{Deterministic Scheduling of Periodic Messages for Cloud RAN}
 

\author[1]{Dominique Barth}
\author[1,2]{Ma\"el Guiraud}
% \author[1]{Christian Cad\'er\'e}
% \author[2]{Brice Leclerc}
% \author[2]{Olivier Marc\'e}
\author[1]{Yann Strozecki}
\affil[1]{David Laboratory, UVSQ}
\affil[2]{Nokia Bell Labs France}

\begin{document}

\maketitle

\begin{abstract}
A recent trend in mobile networks is to centralize in distant data-centers the processing units which were attached to 
antennas until now. The main challenge is to guarantee that the latency of the periodic messages sent from the antennas to their processing
units and back, fulfills protocol time constraints. We show that traditional statistical multiplexing does not allow such a low latency, due to collisions and buffering at nodes. Hence, we propose in this article to use a deterministic scheme for sending periodic messages without collisions in the network thus saving the latency incurred by buffering.

We give several algorithms to compute such schemes for a common topology where one link is shared by all antennas.
We show that there is always a solution when the routes are short or the load is small. When the parameters are unconstrained,
and some buffering is allowed in the processing units, we propose an algorithm (PMLS) adapted from a classical scheduling method.
The experimental results show that even under full load, most of the time PMLS finds a deterministic sending scheme with no latency.
\end{abstract}


\section{Introduction}

Next generations of mobile network architectures evolve toward centralized radio network architectures called C-RAN for Cloud Radio Access Network, to reduce energy consumption costs~\cite{mobile2011c} and more generally the total cost of ownership. The main challenge for this type of architecture is to reach a latency compatible with transport protocols~\cite{ieeep802}. The latency is measured between the sending of a message by a Remote Radio Head (RRH) and the receptions of the answer, computed by real-time virtualized network functions of a BaseBand Unit (BBU)\footnote{Others terminologies exist in the literature. The results of this work are fully compatible with any C-RAN architecture definition.} in the cloud. For example, LTE standards require to process functions like HARQ (Hybrid Automatic Repeat reQuest) in $3$ms~\cite{bouguen2012lte}. In 5G, some services need end-to-end latency as low as $1$ms~\cite{3gpp5g,boccardi2014five}. The specificity of the C-RAN context is not only the latency constraint, but also the periodicity of the data transfer in the \emph{frontaul} network between RRHs and BBUs: frames need to be emitted and received each millisecond~\cite{bouguen2012lte}.
Our aim is to operate a C-RAN on a low-cost shared switched network.
The question we address is the following: is it possible to schedule messages such that there are no collisions to avoid latency caused by queuing delays? 
Eliminating this source of latency leaves us with more time budget for latency due to the physical length of the routes in the network, and thus allows for wider deployment areas.


Let us expose briefly our model: the network topology is modeled by a directed weighted graph and a set of paths (routes) from source nodes (RRHs) to target nodes (BBUs). Time is discretized and a unit of time or slot corresponds to the time needed to transmit a minimal unit of data over the network. Since statistical multiplexing does not ensure a good latency we want to avoid any  buffering in internal nodes of the graph.  We take advantage of the deterministic nature of the messages we must manage i.e. the dates of arrival of messages are known beforehand. In fact, following LTE standard~\cite{bouguen2012lte}, we assume that the arrivals of all the packets are periodic with the same period. We propose to design a \emph{periodic} process to send the messages through the network without collisions. By periodic process we mean that the network at times $t$ and $t+P$ where $P$ is the period, is in the exact same state. 

We assume that the routes of the messages are already fixed, and there are no buffering allowed inside the network. Hence we only have two sets of values that we can set when building a periodic sending process, called a \emph{periodic assignment}: the time at which each packet is sent by an RRH in each period and the waiting time in the BBU before the answer is sent back to the RRH. When building a periodic assignment, we must take into account the periodicity which makes many scheduling methods unusable. Not only a message must not collide with the other messages sent by the others BBU/RRH in the same period, but also in the previous and following periods. The latency, that is the time between the emission of a message and the complete return of its answer must be minimized. This means that the only buffering we are allowed -- the waiting time before sending back the answer-- must be small, in particular when the route is long. Note that the model is technology agnostic, i.e. it is compatible with an optical network with a fixed packet size.   

Our main contributions are the following.
 In Section~\ref{sec:def} we propose a model of the network and the periodic sending of messages along its routes.
 We then formalize our two problems of finding a periodic assignment for sending messages without collisions: \pra (sending of the message only) and \pall (sending of the message and of the answer).  
In Section~\ref{sec:complexity}, we prove that the problem \pra and \pall are $\NP$-hard and cannot be approximated even for very
restricted classes of graphs. 

We introduce in Section~\ref{sec:star_routed_network} a simple but very common topology, called the star routed network, that is studied in the rest of the article.
In Section \ref{sec:PAZL}, we study a variant of \pall called \pazl  where the waiting times must all be zero. We provide  polynomial time algorithms which works when the load or the routes are small, and an FPT algorithm with parameter the number of routes.
We give experimental evidences that they find periodic assignments when the network is not too loaded. Finally in Section \ref{sec:PALL}, we propose polynomial time heuristics and an exact FPT algorithm for the general \pall problem and experimentally show that they work extremely well even in loaded networks. In particular, the deterministic communication schemes we design largely outperform the traditional stochastic multiplexing with regard to latency. 
 \subsection*{Related works}

 Statistical multiplexing even with a large bandwidth does not comply with the latency requirements of C-RAN. Therefore, the current solution~\cite{pizzinat2015things,tayq2017real} is to use dedicated circuits for the fronthaul. Each end-point (RRH on one side, BBU on the other side) is connected through direct fiber or full optical switches. This architecture is very expensive and hardly scales in the case of a mobile network composed of about $10,000$ base stations. The deterministic approach we propose has gained some traction recently: Deterministic Networking is under standardization in IEEE 802.1 TSN group~\cite{finn-detnet-architecture-08}, as well at IETF DetNet working group~\cite{ieee802}. Several patents on concepts and mechanisms for DetNet have been already published, see for example~\cite{howe2005time,leclerc2016transmission}. 
     
The algorithmic problem we focus on may look like wormhole problems~\cite{cole1996benefit}, but we want to minimize the time lost in buffers and not just to avoid deadlocks. Several graph colorings have been introduced to model similar problems such as the allocation of frequencies~\cite{borndorfer1998frequency}, bandwidths~\cite{erlebach2001complexity} or routes~\cite{cole1996benefit} in a network or train schedules~\cite{strotmann2007railway}. Unfortunately, they do not take into account the periodicity of the scheduling and the associated problems are already $\NP$-complete. The only coloring with periodicity is the circular coloring~\cite{zhou2013multiple} but it is not expressive enough to capture our problem. 
The problem \pall on a star routed network is very close to a two flow shop scheduling problem~\cite{yu2004minimizing}
with the additional constraint of periodicity. To our knowledge, all periodic scheduling problems are quite different from \pall.
Either the aim is to minimize the number of processors on which the periodic tasks are scheduled~\cite{korst1991periodic,hanen1993cyclic} while our problem correspond to a single processor and a constraint similar to makespan minimization. Or, in cyclic scheduling~\cite{levner2010complexity}, the aim is to minimize the period of a scheduling to maximize the throughput, while our period is fixed. 


\section{Model and Problems}\label{sec:def}

We use the notation $[n]$ to denote the interval of $n$ integers $\{0,\dots,n-1\}$.


  \subsection{Network modeling}
  
The network is modeled as a directed graph $G=(V,A)$. Each arc  $(u,v)$ in $A$ is labeled by an integer weight $\Omega(u,v)$ which represents the time taken by a message to go from $u$ to $v$ using this arc. A {\bf route} $r$ in $G$ is a directed path, that is, a sequence of adjacent vertices $u_0, \ldots , u_{l}$, with $(u_i,u_{i+1}) \in A$.  The {\bf latency} of a vertex $u_i$ in a path $r=(u_0,\dots,u_l)$ is defined by $\lambda(u_i,r)= \sum\limits_{0 \leq j <i} \Omega(u_j, u_{j+1})$. We also define $\lambda(u_0,r)=0$. The length of the route $r$ is defined by $\lambda (r)= \lambda (u_l,r)$.
We denote by $\cal R$ a set of routes, the pair $(G,\cal R)$ is called a {\bf routed network} and represents our telecommunication network.
The first vertex of a route models an antenna (RRH) and the last one a data-center (BBU) which processes the messages sent by the antenna.

   \subsection{Messages dynamic}
	 
    Time is discretized, hence the unit of all time values is a slot, the time needed to transmit a minimal unit of data over the network. The weight of an arc is also expressed in slots, it is the time needed by a message to go through this arc.
        In the process we study, a message is sent on each route at each period, denoted by $P$.
      Let $r=(u_0,\dots,u_l)$ be a route, if a message is sent at time $m$ from $u_0$ the first vertex of $r$ then it will arrive at vertex $u_i$ in $r$ at time $m + \lambda(u_i,r)$. Since the process is periodic, if the message from $r$ goes through an arc at time $t\in [0,P-1]$, 
      then it goes through the same arc at time $t+kP$ for all positive integers $k$. Therefore, every time value can be computed modulo $P$ and we say that the first time slot at which a message sent at time $m$ on $r$ reaches a vertex $u_i$ in $r$ is $t(u_i,r) = m + \lambda(u_i,r)\mod P$. 
      
      A message usually cannot be transported in a single time slot. We denote by $\tau$ the number 
      of \emph{consecutive slots} necessary to transmit a message. In this paper, we assume that $\tau$ is the same for all routes. Indeed, the data flow sent by an RRH to its BBU is the same, regardless of the route. Let us call $[t(u,r)]_{P,\tau}$ the set of time slots used by route $r$ at vertex $u$ in a period $P$, that is $[t(u,r)]_{P,\tau} = \{t(u,r) + i \mod P \mid 0 \leq i < \tau \}$. 
%       Usually $P$ and $\tau$ will be clear from the context and we will denote $[t(v,r)]_{P,\tau}$ by $[t(v,r)]$.
      Let $r_1$ and $r_2$ be two routes, on which messages are sent at time $m_1$ and $m_2$ in their first vertex.
      We say that the two routes have a {\bf collision} if they share an arc $(u,v)$ and $[t(u,r_{1})]_{P,\tau} \cap [t(u,r_{2})]_{P,\tau} \neq \emptyset$.
      
         A {\bf $(P,\tau)$-periodic assignment} of a routed network $(G,\cal R)$ is a function that associates to each route 
         $r \in \cal R$ its \textbf{offset} $m_r$ that is the time at which a message is emitted at the first vertex of the route $r$.  In a $(P,\tau)$-periodic assignment, \emph{no pair of routes has a collision}.
	 
	 
      As an example of a $(2,1)$-periodic assignment, let us consider a routed network 
      where all pairs of routes intersect at a different arc. It is easy to design such a network and an example is given in Figure~\ref{fig:example}. We set $\tau = 1$ and the weights are chosen so that if $r_{i}$ and $r_{j}$ have $u$ as first common vertex then we have $\lambda(u,r_{i}) - \lambda(u,r_{j})=1$. There is a $(2,1)$-periodic assignment by setting all $m_{i}$ to $0$.

  
      \begin{figure}[ht]
      \begin{center}
          \scalebox{0.47}{
          
\begin{tikzpicture}


\tikzset{
  LabelStyle/.style = { rectangle, rounded corners, draw,
                       font = \bfseries },
  EdgeStyle/.append style = {->} }
  \SetGraphUnit{5}
  \node[draw,circle] (s3) at (4, 2) {$s_2$}; 
  \node[draw,circle] (s2) at (0, 4) {$s_1$}; 
  \node[draw,circle] (s1) at (0, 6) {$s_0$}; 

  \node[draw,circle] (t3) at (14, 7) {$t_2$}; 
  \node[draw,circle] (t2) at (14, 4) {$t_1$}; 
  \node[draw,circle] (t1) at (10, 2) {$t_0$}; 

  
  \SetVertexNoLabel
  \Vertex[x=2,y=5]{A}
  \Vertex[x=4,y=5]{B}
  \Vertex[x=10,y=5]{C}
  \Vertex[x=12,y=5]{D}
  \Vertex[x=6,y=3]{E}
  \Vertex[x=8,y=3]{F}
  \tikzset{
  EdgeStyle/.append style = {green} }
  \Edge[label = 2](s2)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 2](B)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t2)

  
   \tikzset{
  EdgeStyle/.append style = {red} }
  \Edge[label = 2](s3)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(C)
  \Edge[label = 1](C)(D)
  \Edge[label = 1](D)(t3) 
     \tikzset{
  EdgeStyle/.append style = {blue} }
  \Edge[label = 1](s1)(A)
  \Edge[label = 1](A)(B)
  \Edge[label = 1](B)(E)
  \Edge[label = 1](E)(F)
  \Edge[label = 1](F)(t1)

\end{tikzpicture}

}
     \end{center}
       \caption{A routed network with $(0,0,0)$ as a $(2,1)$-periodic assignment}
       \label{fig:example}
      \end{figure}

      \subsection{Periodic route assignment}\label{nonmonotone}

    We want to find an assignment which allows to send periodic messages from sources to targets
    without collisions. We introduce the following associated decision problem, useful for hardness proofs.
    

      \noindent {\bf  Periodic Routes Assignment (\pra)} 

      \noindent {\bf Input:} a routed network $(G,\cal R)$, an integer $\tau$ and an integer $P$.

      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic assignment of $(G,\cal R)$ ?


      We will prove in Section~\ref{sec:complexity} that the problem \pra is $\NP$-complete, even in restricted settings.
      In fact, approximating the smallest value of $P$ for which there is a $(P,\tau)$-periodic assignment is already hard.
      
      An unusual property of assignment is that given a routed network, we may have a $(P,\tau)$-periodic assignment but no
      $(P',\tau)$-periodic assignment with $P' > P$: the existence of an assignment is not monotone with regard to $P$.

	\begin{lemma} \label{lemma:monotonic}
	 For any odd $P$, there is a routed network such that there is a $(2,1)$-periodic assignment but no $(P,1)$-periodic assignment.
	\end{lemma}
\begin{proof}

      We consider a generalization of the routed network $(G,{\cal R})$ given in Figure~\ref{fig:example}. 
      There are $n$ routes in the routed network and each pair of routes $(r_i,r_j)$ share a single arc, which is not in any other route. The weights are chosen so that for $v$, the first vertex which belongs to $r_i$ and $r_j$, we have $\lambda(v,r_i) - \lambda(v,r_j)= P$, where $P$ is an odd number smaller than $n$. In such a graph, there is no $(P,\tau)$-periodic assignment, since the problem reduces to finding a $P$-coloring in a complete graph with $n > P$ vertices, the colors being the offsets of the routes.\\
      If we consider a period of $2$, for all $i \neq j$, $\lambda(v,r_i) - \lambda(v,r_j) \mod 2 = 1$ . Therefore $(0,\dots,0)$ is a $(2,1)$-periodic assignment of ${\cal R}$.      
\end{proof}
      
      
      \subsection{Periodic assignment for low latency}
      
   In the context of cloud-RAN applications, we need to send a message from an RRH $u$ to a BBU $v$ and then 
      we must send the answer from $v$ back to $u$. We say that a routed network $(G, {\cal R})$ is \textbf{symmetric} if the set of routes is partitioned into the sets $F$ of \textbf{forward routes} and $B$ of \textbf{backward routes}. There is a bijection $\rho$ between $F$ and $B$ such that for any forward route $r \in F$ with first vertex $u$ and last vertex $v$, the backward route $\rho(r) \in B$ has first vertex $v$ and last vertex $u$. In all practical cases the routes $r$ and $\rho(r)$ will be the same with the orientation of the arcs reversed, which corresponds to bidirectional links in \emph{full-duplex} networks, but we need not to enforce this property.
         
      We now give a new interpretation of a $(P,\tau)$-periodic assignment of a $(G,{\cal R})$ symmetric routed network, so that it represents the sending of a message and of its answer.
      This assignment represents the following process: First a message is sent at $u$, through the route $r \in F$, at time $m_r$.
      This message is received by $v$, i.e., the last vertex of $r$ at time $t(v,r)$. The answer is then sent back to $u$ on the route $\rho(r)$ in the same period at time $m_{\rho(r)}$ if $m_{\rho(r)} > t(v,r)$, otherwise at time $m_{\rho(r)}$ in the next period. The time between the arrival of the message and the time it is sent back is called the \textbf{waiting time} and is defined by $w_r = m_{\rho(r)} - t(v,r)$ if $m_{\rho(r)} > t(v,r)$ and $w_r = m_{\rho(r)} + P - t(v,r)$ otherwise. Figure~\ref{fig:assignment} illustrates this process in an RRH and its corresponding BBU.
 
     \begin{figure}[h]
      \begin{center}
      \includegraphics[width=0.47\textwidth]{rrh.pdf}
      \end{center}
      \caption{Periodic process}\label{fig:assignment}
      \end{figure}
      
      Note that, in the process we describe, we do not take into account the computation time a BBU needs to deal with one message. It can be encoded in the weight of the last arc leading to the BBU and thus we do not need to consider it explicitly in our model. 
      The whole process time for a message sent on the route $r$ is equal to $PT(r)=\lambda(r)+ w_r+\lambda(r)$.      
      In the process time, we count the time between the time the first slot of the message is emitted and the first time at which the first slot of the message comes back. Alternatively we could consider the time between the emission of the first slot and the reception of the last slot of the message, which adds $\tau$ to the process time. Both definitions are equivalent in our context where all messages are of size $\tau$, hence we chose the first definition which is slightly simpler. 
      Each route must respect a time limit that we call \emph{deadline}. To represent these deadlines, 
      we use a deadline function $d$, which maps to each route $r$ an integer such that $PT(r)$ must be less than $d(r)$.
      
%     The {\bf maximum process time} of the assignment $m$ of $(G,{\cal R})$ is defined by $MPT(m)=\max\limits_{r \in {\cal R}} PT(r)$.
      We consider the following decision problem.

      \noindent {\bf Periodic Assignment for Low Latency (\pall)} 

      \noindent {\bf Input:}  A symmetric routed network $(G,{\cal R})$, the integers $P$, $\tau$ and a deadline function $d$.
      
      \noindent {\bf Question:} does there exist a $(P,\tau)$-periodic assignment $m$ of $(G,{\cal R})$ such that for all $r \in {\cal R}$, $PT(r) \leq d(r)$?

      As a consequence of the $\NP$-hardness of \pra, we show in the next subsection that this problem is $\NP$-hard. 
      In Section~\ref{sec:PALL} we will study heuristics used to solve the search version of \pall (computing an assignment), also denoted by \pall for simplicity. In \pall, we have chosen to bound the process time of each route, in particular we can control the worst case latency. It is justified by our C-RAN application with hard constraint on the latency. It would be interesting to study the case of a constraint on the \emph{average} of process times (or equivalently waiting times) of routes, which may be more relevant in other contexts.

     
      The following table summarize the main notations used in the paper.
      \begin{center}
   \begin{tabularx}{0.5\textwidth}{|c|X|}
    \hline
     $(G,\cal R)$ & Routed network \\
     \hline
      $\Omega(u,v)$ & Weight of the arc $(u,v) \in A$ \\
      \hline
      $\lambda(u_i,r)$ & Latency of the vertex $u_i$ in $r$\\
         \hline
         $\lambda(r)$ & Length of the route $r$\\
         \hline
         $P$ & Period\\
         \hline
         $\tau$ & Size of a message\\
         \hline
         $ [t(v,r)]$& Set of time slots used by route $r$ at vertex $v$ in a period $P$\\
         \hline 
         $m=(m_0, \ldots ,m_{n-1})$& Assignment: an offset for each route\\
              \hline 
         $w_r$& Waiting time of the route $r$\\
            \hline 
         $PT(r)$& Process time of the route $r$\\
           \hline 
       $d(r)$ & Deadline of the route $r$\\
    \hline

      \end{tabularx}
      \end{center}


\section{Hardness of \pra}
  \label{sec:complexity}

 In this section we always assume that the size of a message $\tau$ is equal to one. 
 We will prove the hardness of \pra and \pall for $\tau =1$ which implies the hardness of problems with $\tau$ unconstrained. 
Consider an instance of the problem \pra, i.e., a routed network $(G,\cal{R})$ and a period $P$.
The {\bf conflict depth} of a route is the number of arcs of the route which also belong to other routes.
The conflict depth of a routed network $(G,\cal{R})$ is the maximum of the conflict depth of its routes.
The {\bf conflict width} of a routed network is the maximal number of routes sharing the same arc.
Remark that a $(P,1)$-periodic assignment must satisfy that $P$ is larger or equal to its conflict width.


We give two alternate proofs that \pra is $\NP$-complete.
The first proof works already for conflict depth two. Remark that for conflict depth one,
the graph can be seen as a set of disjoint pair of routes, on which \pra and \pall can be solved in linear time. 
 The second proof reduces the problem to graph coloring and implies inapproximability when one tries to find the smallest possible $P$.  Finally, it is easy to see that \pra is easy on trees and it may be interesting to study its complexity on 
 bounded treewidth networks, since it is a common property of real networks~\cite{de2011treewidth}.
 

 \begin{theorem}
Problem \pra is $\NP$-complete on the class of routed networks with conflict depth two.
\end{theorem}
 \begin{proof}
 Problem \pra is in $\NP$ since given an offset for each route in an assignment, it is easy to check in linear time with regard to the number of arcs whether there are collisions.
 
  Let $H=(V,E)$ be an undirected graph and let $d$ be its maximal degree. We consider the problem to determine whether $H$ is arc-colorable  with $d$ or $d+1$ colors. The arc coloring problem is $\NP$-hard~\cite{holyer1981np} and we reduce it to \pra to prove its $\NP$-hardness. To do that, we define from $H$ a routed network $(G,{\cal R})$ as follows.
  The vertices of $G$ are $v_1, v_2$ for each $v$ in $V$ and $s_{u,v}, t_{u,v}$ for each $(u,v) \in E$.
  For each arc $(u,v) \in E$, there is a route $s_{u,v},u_1,u_2,v_1,v_2,t_{u,v}$ in ${\cal R}$. 
  
   To define ${\cal R}$ an arbitrary orientation of each edge is chosen. 
   Then for each arc $(u,v)$ there is a route $s_{u,v},u_1,u_2,v_1,v_2,t_{u,v}$ in ${\cal R}$.
  All these arcs are of weight $0$. The set of arcs of G is the union between all the arcs of the previously defined routes.
   
  Observe that the existence of a $d$-coloring of $H$ is equivalent to the existence of a $(d,1)$-periodic assignment
  of $(G,{\cal R})$. Indeed, a $d$-coloring of $H$ can be seen as a labeling of its arcs by the integers
  in $[d]$ and we have a bijection between $d$-colorings of $H$ and offsets of the routes of ${\cal R}$.
  By construction, the constraint of having no collisions between the routes is equivalent to the fact that no two adjacent arcs have the same color. Therefore we have reduced arc coloring to \pra by a polynomial time transformation which concludes the proof. 
 \end{proof}
 
 Remark that we have used zero weights in the proof. If we ask the weights to be strictly positive, which makes sense in our model since they represent the delay of physical links, it is easy to adapt the proof. We just have to set them so that in any route the weight at $u_1$ is equal to $d$ and thus equal to $0$ modulo $d$. We now lift this hardness result to the problem \pall.

\begin{corollary}
Problem \pall is $\NP$-complete on the class of routed networks of conflict depth two.
\end{corollary}
\begin{proof}
 We consider $((G,{\cal R}),P,\tau)$ an instance of \pra. We assume that no vertex is the first of some route and the last of another one. Remark that this condition is satisfied in the previous proof, which makes the problem \pra restricted to this kind of instance $\NP$-complete. 
 Let us define $d(r) = 2 \times \max_{r' \in {\cal R}} \lambda(r') + P$. We define $(G',{\cal R}')$ a symmetric routed network from $(G,{\cal R})$ where for every route we add a symmetric route with new arcs of opposite orientation and the same weights.
 We prove that the instance $((G',{\cal R'}),P,\tau,d)$ is in \pall if and only if $((G,{\cal R}),P,\tau)$ is in \pra.
 If $((G',{\cal R'}),P,\tau,d)$ is in \pall, then a $(P,\tau)$-assignment of $(G',{\cal R'})$ restricted to $\R$ is a $(P,\tau)$-assignment of $((G,{\cal R})$ since they cannot be any collision between routes of ${\cal R}$.
 
 Assume now that $((G,{\cal R}),P,\tau)$ is in \pra. First, remark that the waiting time of each route is by definition less than $P$ and thus we have for all $r\in {\cal R}$, $PT(r) \leq d(r)$. Moreover a $(P,\tau)$-assignment of $(G,{\cal R})$ can be extended into a $(P,\tau)$-assignment of $(G',{\cal R'})$ in the following way. For each route $r \in \cal{R}$ of last vertex $v$, the time at which the message arrives is $t(v,r)$, then we choose as offset for $\rho(r) \in \cal{R}'$ $-t(v,r) \mod P$. The symmetry ensures that each new route $\rho(r)$ in ${\cal R'}$ uses exactly the same time slots as $r$ on each of its node and thus avoid collisions.
\end{proof}

Let \minpra be the problem, given a routed network and an assignment, to find the minimal period $P$ such that there is a $P$-periodic assignment. 

\begin{theorem}\label{th:inapprox}
If $\P \neq \NP$, problem \minpra on the classes of routed networks of conflict width two cannot be approximated in polynomial time within a factor $n^{1-o(1)}$ where $n$ is the number of routes.
\end{theorem}

\begin{proof}
 We reduce graph coloring to \pra. Let $H$ be a graph instance of the $k$-coloring problem. 
 We define ${\cal R}$ in the following way: for each vertex $v$ in $H$, there is a route $r_v$ in ${\cal R}$.
 Two routes $r_v$ and $r_u$ share an arc if and only if $(u,v)$ is an arc in $H$; this arc is the only one shared by these two routes. All arcs are of weight $0$. Note that it is easy to build a graph with such routes as in Figure~\ref{fig:reduction}.
 
 Observe that the existence of a $k$-coloring of $H$ is equivalent to the existence of a $(k,1)$-periodic assignment in $G$, 
 by converting an offset of a route into a color of a vertex and reciprocally. Therefore if we can approximate the minimum value of $P$ within some factor, we could approximate the minimal number of colors needed to color a graph within the same factor. The proof follows from the hardness of approximability of finding a minimal coloring~\cite{zuckerman2006linear}.
\end{proof}


In particular, this reduction shows that even with small maximal load, the minimal period can be large.

    \begin{figure}[ht]
    \centering
    \scalebox{0.37}{
    \begin{tikzpicture}
    \tikzset{
      LabelStyle/.style = { rectangle, rounded corners, draw,
			  font = \bfseries },
      EdgeStyle/.append style = {->} }
      \SetGraphUnit{5}
      
      
      \node[draw,circle] (s3) at (4, 2) {$s_2$}; 
      \node[draw,circle] (s2) at (0, 4) {$s_1$}; 
      \node[draw,circle] (s1) at (0, 6) {$s_0$}; 

      \node[draw,circle] (t3) at (12, 3) {$t_2$}; 
      \node[draw,circle] (t2) at (14, 4) {$t_1$}; 
      \node[draw,circle] (t1) at (10, 2) {$t_0$}; 
      

      \tikzstyle{VertexStyle}=[shape = circle, draw, minimum size = 20pt]
	\tikzset{
      VertexStyle/.append style = {blue} }
	\Vertex[x=-8,y=3]{1}
	      \tikzset{
      VertexStyle/.append style = {green} }
	  \Vertex[x=-7,y=5]{2}

	    \tikzset{
      VertexStyle/.append style = {red} }
	  \Vertex[x=-6,y=4]{3}
		\tikzset{
      VertexStyle/.append style = {black} }
      
      
      \SetVertexNoLabel
      \Vertex[x=2,y=5]{A}
      \Vertex[x=4,y=5]{B}
      \Vertex[x=10,y=5]{C}
      \Vertex[x=12,y=5]{D}
      \Vertex[x=6,y=3]{E}
      \Vertex[x=8,y=3]{F}
      \tikzset{
      EdgeStyle/.append style = {green} }
      \Edge(s2)(A)
      \Edge ([yshift=-0.5ex]A.east)([yshift=-0.5ex]B.west)
      \Edge(B)(C)
      \Edge(C)(D)
      \Edge(D)(t2)

      
      \tikzset{
      EdgeStyle/.append style = {red} }
       \Edge ([yshift=-0.5ex]E.east)([yshift=-0.5ex]F.west)
      \Edge(s3)(E)
      \Edge(F)(t3) 
	\tikzset{
      EdgeStyle/.append style = {blue} }
      \Edge(s1)(A)
     \Edge ([yshift=0.5ex]A.east)([yshift=0.5ex]B.west)
      \Edge(B)(E)
             \Edge ([yshift=0.5ex]E.east)([yshift=0.5ex]F.west)
      \Edge(F)(t1)
      
	\tikzset{
      EdgeStyle/.append style = {black,-} }

      \Edge(1)(2)
      \Edge(1)(3)
    \node (1) at (-3,4){\Huge $\rightarrow$};
%     
%     \node (2) at (-7,0){\Huge H};
%     \node (3) at (10,0){\Huge G};
    \end{tikzpicture}
    }
    \caption{Reduction from k-coloring to \minpra}
    \label{fig:reduction}
    \end{figure}
    
\section{The Star Routed Network} \label{sec:star_routed_network}
  
   
    
       Let us define a family of simple routed networks modeling a Point-to-Multipoint fronthaul (PtMP), which has been designed for C-RAN \cite{tayq2017real}. 
      The graph $G$ has two sets of vertices, $S=\{s_0,...,s_{n-1}\}$ and $T=\{t_0,...,t_{n-1}\}$ of cardinality $n$ and two special nodes: the central source node {\bf $c_s$} and the central target node {\bf $c_t$}.
      There is an arc between {\bf $c_s$} and {\bf $c_t$} and for all $i$, there is an arc between $s_i$ and $c_s$ and between $t_i$ and $c_t$. All the symmetric arcs are also in the graph with the same weights.
      The forward routes are the directed paths $r_i = (s_i,c_s,c_t,t_i)$ and $\rho(r_i) = (t_i,c_t,c_s,s_i)$ which define a symmetric routed network. 
      The symmetric routed networks $(G, \{r_i,\rho(r_i)\}_{i<n})$ is called a \textbf{star routed network}. This topology may seem simplistic, but every network in which all routes share an arc can be reduced to a star routed network. It is common in fronthaul networks, since often all the BBUs are located in the same data-center. In such a situation, we can see the weights of the arcs $(c_t,t_i)$ either as all equals (in that case, the problem is trivial, see Section \ref{sec:PALL}) or different due to the structure of the network inside the data-center and the various hardwares used for different BBUs. This topology has conflict depth one (but a maximal conflict width), hence \pra can be solved in polynomial time.
      \begin{figure}
       \begin{center}
	 \scalebox{0.8}{
\begin{tikzpicture}

\tikzset{EdgeStyle/.style={<->,font=\scriptsize,above,sloped,midway}}
  \SetGraphUnit{5}
  
  \node[draw,circle] (s3) at (0, 0) {$s_2$}; 
  \node[draw,circle] (s2) at (0, 2) {$s_1$}; 
  \node[draw,circle] (s1) at (0, 4) {$s_0$}; 

  \node[draw,circle] (t3) at (8, 0) {$t_2$}; 
  \node[draw,circle] (t2) at (8, 2) {$t_1$}; 
  \node[draw,circle] (t1) at (8, 4) {$t_0$}; 
  

  \node[draw,circle] (cs) at (3, 2) {$c_s$}; 
  \node[draw,circle] (ct) at (5, 2) {$c_t$}; 

  
  \Edge[label = $\Omega(s_1\,c_s)$](s1)(cs)
  \Edge[label = $\Omega(...)$](s2)(cs)
  \Edge[label = $\Omega(...)$](s3)(cs)
  
  \Edge[label = $\Omega(...)$](ct)(t1)
  \Edge[label = $\Omega(...)$](ct)(t2)
  \Edge[label = $\Omega(...)$](ct)(t3)
  
  \Edge(cs)(ct)

  
\end{tikzpicture}
}

  \end{center}
  \caption{A star routed network}
  \end{figure}
	
	
  When solving $\pall$ on a star routed network, we can do several assumptions on the parameters of the network  without loss of generality. 
  
  \begin{proposition}\label{prop:canonical}
   Let $I = ((G,{\cal R}), P, \tau , d)$ be an instance of \pall, then there is another instance 
   $I' = ((G',{\cal R}), P, \tau , d')$ such that:
   \begin{itemize}
    \item $I \in \pall \Leftrightarrow I' \in \pall$
    \item $\Omega(c_s,c_t) = 0$
    \item $\forall i<n, \, \Omega(s_i,c_s) =0$
    \item $\forall i<n, \, \Omega(c_t,t_i) + \Omega(t_i, c_t) < P$
   \end{itemize}
  \end{proposition}

  \begin{proof}
   We explain how we build $G'$ and $d'$ from $G$ and $d$ in such a way that there is a bijection 
   between the satisfying assignments of $I$ and $I'$, which proves the proposition.
    
  The central arc appears in every route, therefore when we change it, it does not change 
  the satisfying assignments. If we subtract twice its weight to $d(r)$ for each $r$, and set its
  weight to zero in $G'$, then the constraints $PT(r) \leq d(r)$ will be the same in $I$ and $I'$.
      
  In $G'$, the weights of the arcs $(s_i,c_s)$ is set to $0$ and $2\Omega(s_i,c_s)$
  is subtracted to $d(r_i)$. Hence the deadline constraints are the same in $I$ and $I'$.
  There is a bijection between the assignments of $I$ and $I'$ by mapping $m_i$ to $m_i + \Omega(s_i,c_s)$.
  
  Finally, we can subtract $P/2$ to $\Omega(c_t,t_i)$ and $\Omega(t_i,c_t)$ if we subtract $P$ to $d(r_i)$.
  The constraints on collisions of message are modulo $P$ and thus do not change. The deadline constraints are left unchanged since the two modifications cancel out. Therefore to obtain $I'$, we remove $P/2$ enough time to each  $\Omega(t_i,c_t)$ and $\Omega(c_t,t_i)$ so that $\Omega(c_t,t_i) + \Omega(c_t,t_i)< P$. 
  \end{proof}

   From now on, we assume that all star routed networks have the properties given in Proposition~\ref{prop:canonical}.
  Collisions between messages can only appear on the arc $(c_s,c_t)$ between forward routes or on the arc $(c_t,c_s)$
  between backward routes. The flow of messages in a star routed network is completely described by their repartition in two time windows of size $P$, the {\bf forward period} which contains all $[t(c_s,r)]_{P,\tau}$ with $r$ a forward route and the {\bf backward period} which contains all $[t(c_t,r)]_{P,\tau}$ with $r$ a backward route.

\section{Assignments with waiting times zero} \label{sec:PAZL}
  
  In this subsection, we deal with a simpler version of the problem \pall.
  We ask for a $(P,\tau)$-periodic assignment {\bf with all waiting times equal to $0$}, that is $d(r) = 2\lambda(r)$ and we call this restriction {\bf Periodic Assignment for Zero Latency} or \pazl. We study \pazl since it is simpler, in particular 
  choosing the offset $m_r$ also sets the offset of the route $\rho(r)$ to $m_{\rho(r)} = m_{r} + \lambda(r) \mod P$.
  We get better theoretical results and practical algorithms for \pazl than for \pall. Moreover, as we show in our experimentations of Section~\ref{sec:exp_PAZL}, this problem can very often be solved positively (albeit less often than the general problem). Finally, a solution to \pazl is simpler to implement in real telecommunication networks, since we do not need to implement any buffering at all.    
  
   The problem \pazl is similar to the minimization of makespan in a two flow-shop with delays (see Section~\ref{sec:braheuristic}), a problem known to be $\NP$-complete~\cite{yu2004minimizing}. It suggests that \pazl is $\NP$-complete, however we have not been able to prove it yet,  because the periodicity is hard to deal with. With additional constraints we can get rid of the periodicity in the hardness proof, for instance if we consider that the central link is unidirectional, that is collisions can happen between messages going from $c_s$ to $c_t$ and messages  going from $c_t$ to $c_s$. This variant can be shown to be $\NP$-complete by a reduction from the subset sum problem as it is done for a similar problem of scheduling pair of tasks~\cite{orman1997complexity}.
  On the other hand we show positive results:  when the period is large or when the routes are short there is always a solution to \pazl and it can be found in polynomial time. We also give a fixed parameter tractable algorithm which finds a solution to \pazl if there is one in time exponential in the number of routes only. 
  
\subsection{Shortest-longest policy}
    

    We first present a simple policy, which works when the period is large with regard to the lengths of the routes.
    The messages are sent in order from the shortest route to the longest route, without any gap between two messages in the forward period.
    In other words, we assume that the route $r_i$ are sorted by increasing $\lambda(r_i)$ and we set $m_{r_i}$ the offset of $r_i$ to $i\tau$. We call this algorithm {\bf Shortest-Longest}.
      
     By definition, there are no collisions in the forward period and if the period is long enough, 
     it is easy to see that in the backward period the order of the messages are the same as in the forward period and that no collision can occur. 
      
      
      \begin{proposition} Let $(G, {\cal R})$ be a star routed network, and let $n\tau + 2(\lambda(r_{n-1}) - \lambda(r_{0})) \leq P$. There is a $(P,\tau)$-periodic assignment of $(G, {\cal R})$ with waiting times $0$ given by Shortest-Longest in time $O(n\log(n))$.\label{prop:SL}
      \end{proposition}
      \begin{proof}
       Since $m_{r_i} = i\tau$ and $n\tau < P$, $[t(c_s,r_{i})]_{P,\tau} = \{i\tau,\dots, (i+1)\tau -1\}$ and there are no collisions on the forward period.
       
       We may assume that $\lambda(r_{0}) = 0$, since removing $\lambda(r_{0})$ from every arc $(c_t,t_i)$ does not change the order on the length of the routes nor the collisions between messages.
       Since $\lambda(r_{0}) = 0$, by hypothesis we have $n\tau + 2\lambda(r_{n}) \leq P$ which implies that
       $[t(c_t,r_{i})]_{P,\tau} = \{2 \lambda(r_{i}) + i\tau, \dots,  2 \lambda(r_{i}) + (i+1)\tau -1\}$.
       Since $ \lambda(r_{i}) \leq  \lambda(r_{i+1})$ by construction, we have  $2 \lambda(r_{i}) + i\tau -1 < 2 \lambda(r_{i+1}) + (i+1)\tau$ which proves that there are no collisions on the backward period. 
 The complexity of the algorithm is dominated by the sorting of the routes in $O(n\log(n))$. 
      \end{proof}

      If the period is slightly smaller that the bound of Proposition~\ref{prop:SL}, a collision will occur on the first route in the backward period. Hence, this policy is not useful even as a heuristic for longer routes as confirmed by the experimental results of Subsection~\ref{sec:exp_PAZL}. 

   
    \subsection{Greedy algorithm}
    
    
      Let $\frac{n\tau}{P}$ be the \textbf{load} of a star routed network. The load is the proportion of time slots used by messages on the central arc in a period. Therefore if the load is larger than $1$ there cannot be an assignment. We propose a greedy algorithm to build a $(P,\tau)$-periodic assignment, which always finds an assignment when the load is less than $1/3$. Therefore in the rest of the article we will be only concerned with load larger than $1/3$.
    
    \begin{proposition}
    There is a $(P,\tau)$-periodic assignment of a star routed network with waiting times $0$ if the load is less than $1/3$ and it can be found in time $O(n^2)$.
    \end{proposition}
    \begin{proof}
     We consider the forward period and cut it into consecutive intervals of size $\tau$ that we call macro-slots. The algorithm works by choosing an offset for each route in the following way: try all offsets which put the message in a yet not used macro-slot in the forward
     period. Since the choice of an offset also sets the position of the message in the backward period, chose the first one which does not create a collision. We now prove that this algorithm always finds a $(P,\tau)$-periodic assignment without waiting time when $P \geq 3n\tau$ that is the load is less than $1/3$.
     
     Assume we are choosing the offset of the route $r_{k+1}$, we have at least $P - k \geq 3n - k$ free macro-slots in the forward period, since $P \geq 3n\tau$. Each of these $3n - k$ possible offset values translates into $3n - k$ positions of messages in the backward period. All these positions are separated by at least $\tau$ slots. There are already $k$ messages of size $\tau$ in the backward period. One such message can intersect at most $2$ potential positions since they are disjoint intervals. Therefore  amongst the possible $3n - k$ positions, there are  at least $3n - k -2k$ which are without collision. Since $k < n$, $3n - k -2k \geq 1$, which proves that the algorithm terminates and find a  $(P,\tau)$-periodic assignment. 
   
     This algorithm works with a complexity $O(n^2)$, since for the $k^{\text{th}}$ route we have to try at most $2k$ offsets before finding a correct one. We can test the $2k$ offsets of the backward period in time $O(k)$ by maintaining an ordered list of the intervals used by already set routes.
     \end{proof}
     \begin{figure}
      \begin{center}
      \includegraphics[width=0.48\textwidth]{ex3nt.pdf}
      \end{center}
      \caption{Forward and backward period, represented at step $k$ of the algorithm}
      \end{figure}
% 	\begin{algorithm}[H]
% 	\caption{Greedy assignment}
% 	\begin{algorithmic}
% 	\REQUIRE ${\cal R}_{\cal C}$, period $P$
% 	\ENSURE A P-periodic assignment in p $\leq P$, or FAILURE
% 	\STATE $T$ a table of the macro slots of size $\tau$ in the forward period.
% 	\STATE $L$ a list of free intervals in the backward period%$P2[P]$ slots backward period.
% 	\FORALL{source $s$ in S}
% 
% 	\FORALL{free intervals $[a,b]$ in $L$}
% 	\FORALL{ $a/\tau - \lambda(s) <j< b/\tau - \lambda(s)$ }
% 	\IF{ $T[j] == FREE$}
% 	\STATE $m_{s} \leftarrow j.\tau$
% 	\STATE $T[j] = USED$
% 	\STATE update $[a,b]$ in $L$
% 	\STATE BREAK
% 	\ENDIF
% 	\ENDFOR
% 	\ENDFOR
% % 	
% % 	\IF{No intervals are found for $s_i$}
% % 	\STATE return FAILURE
% % 	\ENDIF
% % 	\ENDFOR
% 
% 	\ENDFOR
% 
% 	\end{algorithmic}
% 	\end{algorithm}
	
This algorithm, contrarily to the previous one, may work well, even for loads higher than $1/3$.
In fact, experimental data in Subsection~\ref{sec:exp_PAZL} suggest that the algorithm finds a solution when the load is less than $1/2$. Note that we have experimented with other greedy algorithms which do not use macro-slots, they work even better in practice but they can be proved to work for load less than $1/4$ only.

\subsection{An FPT algorithm}

In this section we show how every assignment without waiting time can be put into a canonical form.
We use that to provide an algorithm which finds an assignment when it exists, in fixed parameter tractable time ($\FPT$) with parameter $n$ the number of routes (for more on parametrized complexity see~\cite{downey2012parameterized}). This is justified since $n$ is small in practice (from $10$ to $20$) and the other parameters such as $P$, $\tau$ or the weights are large.

Let $(G, {\cal R})$ be a star routed network and $m$ a $(P,\tau)$-periodic assignment.
A set of routes $S$ is \textbf{coherent} if for all $r \in {\cal R}$, $r \in S$ if and only if $\rho(r) \in S$. We say that a coherent set $S \subseteq {\cal R}$ is \textbf{compact} for the assignment $m$ if there is a route $r_0 \in S$ such that the following holds:  
for all coherent subsets $S'\subset S$ with $r_0 \notin S'$, if we remove $1$ from all offsets of routes in $S'$ then there is a collision with a route of $S \setminus S'$. We say that $m$ is compact if ${\cal R}$ is compact for $m$. 
% 
% 
% $r_1,r_2 \in {\cal R}$ two forward routes (resp. two backward routes) and 
%  We say that there is no gap between $r_1$ and $r_2$ in $\mathcal{M}$ if $\lambda(r_1,c_s) + \tau = \lambda(r_2,c_s)$ (resp. $\lambda(r_1,c_t) + \tau = \lambda(r_2,c_t)$). It means that the message of $r_2$ goes through the central arc just after the message of $r_1$ withtout wasting time. We say that a set of routes ${\cal R}$ is \textbf{compact} for the assignment $\mathcal{M}$ if for all forward routes $r \in {\cal R}$ but one, there is another forward route $r'$ such that there is no gap between $r'$ and $r$ or between $\rho(r')$ and  $\rho(r)$. If the set of all routes is compact for an assignment, we say that the assignment is compact.

\begin{proposition}
Let $(G, {\cal R})$ be a star routed network. If there is a $(P,\tau)$-periodic assignment of $(G, {\cal R})$, then there is a compact $(P,\tau)$-periodic assignment of $(G, {\cal R})$.
\end{proposition}
\begin{proof}
Consider $m$ a $(P,\tau)$-periodic assignment of $(G, {\cal R})$.
Let $r_0$ be an arbitrary route of ${\cal R}$,  and let $COMP = \{r_0\}$. Now we apply the following algorithm to $m$ and $COMP$ while $COMP$ is not equal to ${\cal R}$.
While there are no collisions, remove $1$ (modulo $P$) from all offsets of routes in ${\cal R} \setminus COMP$. Then choose a route $r$ in ${\cal R} \setminus COMP$ which would have a collision with a route $r'$ of $COMP$ if one is subtracted from its offset. If $r'$ is a forward route, let $COMP = COMP \cup \{r, \rho(r)\}$ otherwise  $COMP = COMP \cup \{r, \rho^{-1}(r)\}$. 

We prove by induction that $COMP$ is compact for $m$ at every step of the algorithm.
At the beginning $|COMP| = 1$ and the property is trivially satisfied. Then we assume that 
$COMP$ is compact and that we add to it $\{r, \rho(r)\}$ at some step of the algorithm. W.l.o.g we assume that it is the offset of $r$ which cannot be decremented without collision. Consider $S \subseteq   COMP$, if $S$ contains an element different from $r$ and $\rho(r)$ by induction hypothesis we cannot decrement the offsets of $S$ without collision. If $S =\{r, \rho(r)\}$
by construction, we cannot decrement the offset of $r$. 

Finally, there are no collisions between routes at the beginning and since we modify $m$ only if it creates no collisions, the assignment we obtain at the end has no collisions between routes.
\end{proof}

We now present an algorithm to find a $(P,\tau)$-periodic assignment by trying all compact assignments.

\begin{theorem}\label{th:FPT}
$\pazl \in \FPT$ when parametrized by the number of routes.
\end{theorem}
\begin{proof}
Let $(G, {\cal R})$ be a star routed network and let $m$ be a $(P,\tau)$-periodic assignment of $(G, {\cal R})$. First, remark that for a given assignment and a route $r_0$ with offset $m$, by removing $m$ to all offsets, we can always assume that its offset is zero. Therefore we need only to consider all \emph{compact assignments} with an \emph{offset $0$} for the route $r_0$. 
We now evaluate the number of compact assignments and prove that it only depends
on $n$ the number of routes which proves the theorem. To count the compact assignment, we describe a way to build a compact assignment $m$ by determining its offsets one after the other, which gives a bound on their number and an algorithm to generate them all. We fix an arbitrary total order on ${\cal R}$.
First a route $r_0$ is chosen arbitrarily and its offset set to $0$. 
Then at each step, if the offsets of $S \subseteq  {\cal R}$ have been chosen,
we select the smallest route $r$ in $S$ for the order. 
Then we select a route in $r' \in {\cal R} \setminus S$ and set its offset such that 
if we remove $1$ then $r'$ collides with $r$. Note that if $r$ is a forward route (resp. a backward route) then $r'$ is also a forward route (resp. a backward route). We can also decide to definitly skip $r$. At a given step of the algorithm, if $|S| = 2i$, we have $n-i$ choices 
of routes to select. The value of the offset of the selected route is entirely determined by the values of the offsets of routes in $S$. Therefore there are at most $n!$ different compact assignments with offset $r_0$ fixed to $0$. 

The algorithm to solve \pazl builds every possible compact assignment as described here, and
tests at each step whether there is a collision, which can be done in time linear in the size of 
$(G, {\cal R})$. Therefore $\pazl \in \FPT$.
\end{proof}

We call the algorithm described in Theorem~\ref{th:FPT} \textbf{Exhaustive Search of Compact Assignments}. To make it more efficient in practice, we make cuts in the search tree used to explore all compact assignments. Consider a set of $k$ forward routes whose offsets has been fixed at some point in the search tree. We consider the times at which the messages of these routes cross the central arc. It divides the period into $[(a_0,b_0), \dots, (a_{k-1},b_{k-1})]$ such that the central arc is free only during the intervals $(a_i,b_i)$. Therefore at most $\displaystyle{ \sum_{i=0}^{k-1} \lfloor(b_{i} -a_i)/\tau\rfloor} $ forward routes can still use the central arc. If this value is less than $n - k$, it is not possible to create a compact assignment by extending the one on $S$ and we backtrack in the search tree. The same cut is used for the backward routes.
% 	\subsubsection*{Exhaustive search}
% % 	\begin{algorithm}[H]
% % 	\caption{Exhaustive Generation}  
% % 	\begin{algorithmic}
% % 	\REQUIRE A routage graph ${\cal R}_{\cal C}$, period $P$, packet size $\tau$
% % 	\ENSURE $(P,\tau)$-periodic assignment of ${\cal R}_{\cal C}$
% % 	\STATE Forward-budget $\leftarrow$ $P$ - n * $\tau$
% % 	\STATE Backward-budget $\leftarrow$ $P$ - n * $\tau$
% % 	\STATE Free-Intervals $\leftarrow$ list of free intervals in the backward period, init to $[0;P[$
% % 	\FORALL{source $s_i$ in S}
% % 	\FORALL{j in Free-Intervals }
% % 	\IF{Message of the route $r_{s_i}$ does not collides with scheduled routes}
% % 	\STATE $m_{s_i} \leftarrow $ the first slot of Free-Intervals[j]
% % 	\STATE Split the Free-Intervals considering the new packet
% % 	\STATE Forward-budget $\leftarrow$ Forward-budget - {\em lost size}
% % 	\STATE Backward-budget $\leftarrow$ Backward-budget - {\em lost size}
% % 	\STATE call Exhaustive Generation on remaining routes
% % 	\ENDIF
% % 	\ENDFOR
% % 	\ENDFOR
% % 
% % 
% %       \end{algorithmic}
% %       \end{algorithm}
% 
% % 	    
%       We now present an exhaustive search algorithm, which tries to set the offsets in all possible ways until it has found a $(P,\tau)$-periodic assignment. Contrarily to the two previous algorithms, when it fails to find a solution, then it certifies there are no solution to \pazl.
%       
%       We have $n$ routes denoted by $\{0,\dots,n-1\}$. A partial solution $S$ is 
%       a partial function from $[n]$ to $\{0,1,\dots,P-\tau -1\}$ which sets a starting time for a subset of the routes $R(S) \subseteq [n]$, such that there are no collisions for these routes.  A partial solution $S'$ extends $S$, if $S'$ is defined over one more route than $S$ and this route has a larger starting offset than all routes of $S$: $R(S') = R(S) \cup \{r'\}$ and for all  $r \in R(S)$, $S(r) + \tau \leq S'(r')$. We define a tree whose nodes are partial solutions and such that the root is the empty partial solution and the children of a partial solution are the partial solutions which extend it. The solutions to our problem will be the leaves of depth $n$ in the tree, and our exhaustive search algorithm is a depth-first search of this tree. 
%       
%       Remark that a node $S$ with $|R(S)| = k$ can have as many as $(n-k)P$ children. Since the tree is of depth $n$, the tree may have as many as $n!P^n$ elements and while $n$ is small, $P$ may be large which makes its traversal intractable.  Therefore we have to find cuts in the tree to avoid to explore it entirely and henceforth make the algorithm practical. Cuts correspond to the detection of subtrees which contain no solutions or solutions which can be found elsewhere and can thus be skipped. We now propose three cuts, the first two being particularly useful when the network is loaded ($n\tau$ is not far from $P$). 
%       
%       \begin{enumerate}
%        \item We consider the number of slots which can be used by routes not yet fixed by a partial solution in the \emph{forward period}. When we extend a solution into $S$ with a new route at offset $m$, then at most $(P - m) / \tau $ routes can still be used to extend $S$ without collisions in the forward period. If that value is less than the number of routes which are not in $R(S)$, it is a failure and the algorithm backtracks.
%        
%        \item 
%        For the next two cuts, we need to define the notion of the useful slots of a partial solution $S$ in the \emph{backward period}: a slot is said to be useful, if it is not used by a message set by $S$ in the backward period and it belongs to an interval of at least $\tau$ such slots. Useful slots are positions of the backward period which can be used when extending $S$. We will denote by $([a_i,b_i[)_{i\leq l}$ the ordered sequence of intervals of useful slots of $S$. Without loss of generality we can assume that all $a_i, b_i \leq l$. The number of messages of size $\tau$ which can be placed in the useful slots of $S$ is thus  $\displaystyle{ \sum_{i=0}^{l} (b_{i} -a_i)/\tau } $. If that value is less than the number of routes which are not in $R(S)$, it is a failure and the algorithm backtracks. Notice that the list of intervals of useful slots and the value $\displaystyle{ \sum_{i=0}^{l} (b_{i} -a_i)/\tau } $ can be maintained in constant time, since each time a route is added, we only need to split an interval of useful slots into at most two such intervals.
%        
%        \item 
%        Let $S_1$ and $S_2$ be two partial solutions with $R(S_1) = R(S_2)$. Let $US_1$ (respectively $US_2$) be the set of useful slots of $S_1$ (resp. $S_2$). We say that \emph{$S_1$ dominates $S_2$} if there are more useful slots both in the forward and backward periods for $S_1$ than for $S_2$. Formally, the largest offset fixed in $S_1$ is smaller than the one in $S_2$ and $US_2 \subseteq US_1$. Remark that any valid sequence of extensions of $S_2$ (choosing offsets of routes in the complementary of $R(S_2)$) is also a valid sequence of extensions of $S_1$. Therefore if the tree rooted at $S_2$ contain a solution, then $S_1$ contains one too. Hence, in our exhaustive search of the tree of partial solutions, we can skip the tree rooted at $S_2$.
%        
%        We now explain how we can detect some partial solutions which are dominated so that we do not explore their subtrees.
%        Consider a partial solution $S$ which we extend into $S'$ by setting the offset of the route $r$ to be the smallest possible. The offset of $r$ in the backward period is $S'(r)+ \lambda$ and we denote the end of the message before before by $a$. Hence all extensions of $S$ into $S''$ such that $S'(r)  < S''(r) < a + \tau - \lambda$ are dominated by $S'$. Therefore when computing the extension of $S$, we first build $S'$ and then $S''$ with $S''(r) =  a + \tau - \lambda$ , skipping all values in between.
%        
%        \end{enumerate}
%       
%       The third cut works well in conjunction with the first one since it makes the offsets grow quickly and 
%       which makes the first cut more likely to apply. A last cut could be implemented: compute for every route not in $R(S)$ the set of possible positions in the backward period and verify whether at least one is contained in the useful slots of $S$.
   
   
   
   \subsection{Experimental evaluation}\label{sec:exp_PAZL}
   
   In this section we compare the experimental results of the three presented algorithms.
      Notice that both Greedy algorithm and Shortest-Longest are polynomial time algorithms but are not always able to find a solution, depending on the load or the size of the routes. On the other hand, exhaustive search finds a solution if it exists, but works in exponential time in $n$. We compare the performance of the algorithms in two different regimes: routes are either short with regard to $\tau$, or unrestricted.
      From the C-RAN context we choose the following parameters: the number of routes is at most $n = 20$, $\tau$ is equal to $2,500$. It corresponds to slots of $64$ Bytes, messages of approximately $1$~Mbit and links of bandwidth $10$~Gbit/s when $P$ is one millisecond ($19531$ slots). 
       The code in C is available on the web page of one author\footnote{\url{http://www.prism.uvsq.fr/~ystr/textesmaths.html}} under a copyleft license. The code has been run on a standard $2016$ laptop, and most experiments run in a few dozen of seconds.

       In the experiments we try to understand how the algorithms work with regards to the load. To change the load, we fix the parameters $\tau$ and $n$ and modify the period $P$, which allows for a smooth control of the load and does not impact the execution time of the algorithms.
      

      \paragraph{Short routes}
      
      First we consider routes which are shorter than $\tau$: a message cannot be contained completely in a single arc which is common in our applications. We generate star routed networks in which the weights of the arcs $(c_t,t_i)$ are drawn uniformly between $0$ and $700$ which corresponds to links of less than $5$km between a BBU and an RRH. 
      
      Our aim is to understand how well the algorithms are working under high load. To do that we evaluate the highest load 
      under which a $(P,\tau)$-periodic assignment can be found by each algorithm when we change the number of routes. 
      In our experiment, we generate $1,000$ random instances of \pazl for $1$ to $14$ routes. We represent in Figure~\ref{fig:short} the average of the maximal load for which each algorithm finds a solution. A bound on the maximum load is given by the exhaustive search which always finds a solution if there is one. 
%       The lower and upper bound $n\tau$ and $3n\tau$ are also represented.
      
        
      \begin{figure}[h]
      \begin{center}
	 \includegraphics[width=0.47\textwidth]{periode_petite.pdf}
      \end{center}
      \caption{Maximal load averaged over $1,000$ random instances}\label{fig:short}
      \end{figure}
      First, we remark that the exhaustive search finds a solution even when the load is high, especially when there are more routes.
      It justifies the idea to look for an assignment without waiting time, in this short routes regime.
      Second, remark that the Shortest-Longest algorithm is as good as the exhaustive search. While it was expected to be good with short routes, it turns out to be optimal for all the the random star routed networks we have tried. Therefore, we should use it in practical applications with short routes, instead of the exhaustive search which is much more computationally expensive. 
      Finally, note that, on average, the greedy algorithm works when the load is less than $2/3$ which is twice better than the theoretical lower bound. This algorithm seems to depends on the load only and not on the number of routes.
      
        \paragraph{Long routes}
      
      We now want to understand the performance of these algorithms when the size of the routes is unbounded. In this experiment we fix the number of routes to $8$ and the weights of the arcs $(c_t,t_i)$ are drawn following a uniform distribution between $0$ and $20,000$ (in the same range as the period). We represent in Figure~\ref{fig:long} the percentage of success of each algorithm, for load from $100\%$ down to $40\%$.
      
\begin{figure}[h]

       \begin{center}
      \includegraphics[width=0.47\textwidth]{echec_longues.pdf}
      \end{center}
       
      \caption{Success rate for $8$ routes over $1,000$ random instances}\label{fig:long}
     \end{figure}
      
      In this regime, the performances of Shortest-Longest are abysmal since it depends on the difference between the longest and the smallest route which is large here. On the other hand, the greedy algorithm has a performance not so far from the case of short routes, which is expected since it does not directly depend on the size of the route. In fact, if we do the previous experiment  (for short routes) but with long routes, we find that, on average, the greedy algorithm finds a solution when the load is less than $59\%$.
      
      When the load is larger than $50\%$, the exhaustive search finds more solutions than the greedy algorithms which justifies its use. However, for load larger than $80\%$ there are many instances for which there are no solutions to \pazl.
      It means that with long routes and high load, looking for an assignment without waiting time is far too restrictive. That is why we present algorithms for the general \pall problem in our next section. We will test them on $8$ long routes and a load between $100\%$ and $80\%$, parameters for which, as shown here, there are often no assignment without waiting times.
      
      The computation time of the exhaustive search is bounded by $O(n!)$ as shown in Theorem~\ref{th:FPT}, 
      but it can be much better in practice, either because it finds a solutions quickly or because a large part of the tree of 
      compact assignments is pruned during the algorithm. We study the scalability  of the algorithm when $n$ grows in the following experiment. The weights of the arcs $(c_t,t_i)$ are drawn following a uniform distribution between $0$ and $20,000$ slots. We chose  $95\%$ of load.  The table of Figure~\ref{fig:table} shows the time before the exhaustive search ends, for $8$ to $16$ routes, averaged on $100$ random star routed networks. This shows that for less than $16$ routes, which corresponds to all current topologies, the algorithm is efficient enough, but we should improve it further to work on more routes.
      
      \begin{figure}[h]
         \begin{center}
         \begin{tabularx}{0.5\textwidth}{|l|X|X|X|X|X|}
    \hline
   $n$ & $8$ & $10$& $12$&$14$& $16$\\
    \hline
   Time (s) & $6.10^{-5}$&$8.10^{-4}$&$2.10^{-2}$& $0.4$& $11$\\
    \hline
      \end{tabularx}
      \end{center}
      \caption{Running time of the exhaustive search.}
      \label{fig:table}
      \end{figure}
      
         \section{Solving \pall on Star Routed Networks}\label{sec:PALL}
    
    In this section, we consider the more general \pall problem on star routed networks. The messages are allowed to wait in the target vertices (BBUs) to yield more possible assignments. Hence, we allow the process time of a route to be greater than twice the weights of the route, but it is bounded by its deadline.

	\subsection{Simpler networks}
		
		
	Often in real networks, the length of the routes are not arbitrary and we may exploit that to solve \pall easily. For instance if all the weights on the arcs $(c_t,t_i)$ are the same, we can replace them all by $0$ and subtract this weight to the deadlines. It corresponds to a situation where all the BBUs are in the same data-center and have the same processing power. The assignment in that case is trivial, just send all messages so that they follow each other without gaps in the central arc. Since the arcs $(c_t,t_i)$ are of weight $0$, all messages will go through $(c_t,c_s)$ on their way back in the same order and thus do not collide. 
	
	Another possible assumption would be that all deadlines are sufficiently large, larger than the longest route.
	It happens when all the arcs $(s_i,c_s)$ of the original star routed network are the same or almost the same.
		
	 \begin{theorem}\label{th:asym}
	 Let $(G,{\cal R})$ be a star routed network with $n$ routes and let $P \geq n\tau$. Assume that the deadline function 
	 satisfies for all $r\in {\cal R}$, $d(r) \leq \displaystyle{\max_{r' \in  {\cal R}} 2\lambda(r')}$. Then, there is a $(P,\tau)$-periodic assignment and it can be built in time $O(n)$.
% 	 $d = \max_{i,j} |\Omega(s_i,c_s) - \Omega(s_j,c_s)$. There is a $(P,\tau)$-periodic assignment with process time $2\, \displaystyle{\max_{r\in {\cal R}} \lambda(r) + d}$ and it can be built in time $O(n)$.
	 \end{theorem}
      \begin{proof}
      W.l.o.g. say that $r_0$ is the longest route. The idea is to set the waiting times of all routes so their messages behave exactly as the message of $r_0$.        
        The offset of the forward route $r_i$ is set to $i\tau$, which ensures that there are no collisions on the arc $(c_s,c_t)$ as soon as $P \geq n\tau$ which is the minimal possible period. The waiting time of the route $r_i$ is $w_i = 2(\lambda(r_{0}) - \lambda(r_{i}))$.
        
        The time at which the message of the route $r_i$ arrives at the vertex $c_t$ on its way back is $t(c_t,\rho(r_i)) = w_i + i\tau + 2\lambda(r_{i})$. By replacing $w_i$ by its value we obtain $t(c_t,\rho(r_i)) =  i\tau + 2\lambda(r_{0})$
        As a conclusion there are no collisions on the arc $(c_t,c_s)$ as soon as the period is larger than $n\tau$ (there are no gaps between the messages). The process time of the route $r_i$ is $PT(r_i) = w_i + 2\lambda(r_{i}) $. We obtain $PT(r_i) = 2\lambda(r_{0})$ which is by hypothesis less than $d(r_i)$.
	Finally the complexity is $O(n)$ since we have to find the maximum of the length of the $n$ routes and the computation of each $w_i$ is done by a constant number of arithmetic operations.
     \end{proof}
     
    
     \subsection{A two stage approach}
     
     We can decompose any algorithm solving \pall in two parts: first set the offsets of the forward routes and then knowing this information set the offset of the backward routes or equivalently the waiting times.   
     
     First, in order to minimize the period needed to send the messages of the forward route, we set the offsets of the forward routes so that all messages have no collisions on the central arc and such that there are no free slots between the end of a message on the central arc and the beginning of the next one.
    % In the following policies, the offsets of the forward routes will be chosen so that all messages have no collisions on the central arc and such that there are no free slots between the end of a message on the central arc and the beginning of the next one. It is done to minimize the period needed to send the messages of the forward route.
     The offsets of the forward routes are then defined by the order of the messages through the central arc. We propose to study the following orders. 
	\begin{itemize}
	 
	 \item Longest-Shortest on Routes (LSR): Decreasing order on the length of the routes.
	 \item Shortest-Longest on Routes (SLR): Increasing order on the length of the routes. 
	 \item Longest-Shortest on last Arc (LSA): Decreasing order on the length of the arcs $(c_t,t_i)$.
	 \item Shortest-Longest on last Arc (SLA): Increasing order on the length of the arcs $(c_t,t_i)$. This sending order yields a $(P,\tau)$ periodic assignment in which all the $w_i = 0$, if the period is large enough (see proposition \ref{prop:SL}).
	 \item Random: A random order of the routes (RO).
	\end{itemize}

%    \todo{On peut commenter la partie suivante si on a pas fini}
    We also study another way to fix the offsets of the forward routes. Instead of packing all messages so that they follow each other
    in the central arc, we allow time between them. The order of the message is random and we consider two variations. 
    Either the time between two messages on the central arc is random and we call this policy Random Order and Random Spacing (RORS) or the space between two consecutive messages is always the same and we call this policy Random Order and Balanced Spacing (ROBS).
 	
    We denote by \bra (backward routes assignment) the problem \pall where the offsets of the forward routes are also given as input.
    In the rest of the section we will study different methods to solve \bra either by polynomial time heuristics or by an FPT algorithm. The method to solve \bra are then combined with the proposed policies for fixing the offsets of the forward routes
    to solve \pall.  
   
   \subsection{Greedy scheduling of backward routes}
    
    Consider a forward route $r_i$, whose offset is $m_{r_i}$ and its backward route is $\rho(r_i)$.
%     We define the {\bf deadline} of $\rho(r_i)$ as $m_{r_i} + T_{max} - \Omega(s_i,c_s)$, that is the latest time at which the message can go out of $c_t$ such that $PT(r_i) \leq T_{max}$.
    We say that a backward route $\rho(r_i)$ is {\bf eligible} at time $t$ if $m_{i} +  \lambda(r_i) + \Omega(c_t,t_i) \leq t$, that is the message of the route $\rho(r_i)$ arrives at $c_t$ before time $t$ when $w_i = 0$.
    
    The first algorithm we propose to solve \bra is a greedy algorithm which sets the offset $m_{\rho(r_i)}$ of the 
    backward routes. It prioritizes the routes with the earliest deadline to best satisfy the
    constraint on the process time. Set $t=0$ and repeat the following: find $s \geq t$ the first time for which there is an eligible route with its offset not fixed. Then amongst all eligible routes at time $s$ choose the one with the smallest deadline, fix its offset to $s - \Omega(c_t,t_i) $ and set $t = s + \tau$.
    
    This algorithm does not take into account the periodicity. Say that $t_0 = t(c_t,r)$ such that $r$ is the first backward route selected by the algorithm. Then if all backward routes $r$ are such that $t(c_t,r)$ is smaller than $t_0 + P - \tau$,
    by construction, there are no collisions on the central arc.
    However, if a route $r$ has a larger $t(c_t,r)$, since we should consider everything modulo $P$, 
    it may collide with another backward route. Therefore we must adapt the greedy algorithm of the previous paragraph by finding $s \geq t$ the first time for which there is an eligible route with its offset not fixed and \emph{such that there are no collisions if a message go through the central arc at time $s$}. 
    
    Algorithm~\ref{alg:GD} is the formal description of the previous algorithm. 
     The function  min\_non\_assigned(eligible\_time) returns the non assigned route with the smallest time eligible time. The function update(t,free\_intervals) removes an interval of size $\tau$ beginning at t, which correspond to the message,  from free\_intervals.
     
      \begin{algorithm}\label{alg:GD}
     \caption{ Greedy deadline ({\bf GD}) }
     \begin{algorithmic}
     \REQUIRE A routed network $(G,{\cal R})$, a period $P$, packet size $\tau$, the deadlines $d_i$, the offsets $m_i$
     \ENSURE $(P,\tau)$-periodic assignment of $(G,{\cal R})$, or failure
    \STATE  ${\cal H} \leftarrow$ empty set //{\em set of eligible routes with their deadline}
        \STATE  free\_ intervals $\leftarrow$ [0,$P$] //{\em list of intervals of free slots}
   
     \FORALL{route $r_{i}$}
%      \STATE  deadline[$r_i$]  $\leftarrow$  $m_{i} + T_{max} - \Omega(s_i,c_s)$
     \STATE  eligible\_time[$r_i$] $\leftarrow$ $m_{i} +  \lambda(r_i) + \Omega(c_t,t_i)$
       \ENDFOR
       
       \WHILE{There is some non-assigned routes}
       \IF{${\cal H}$ is empty}
       \STATE $r_i$ $\leftarrow $ min\_non\_assigned(eligible\_time)
       \STATE insert(${\cal H}$,$r_i$,$d_i$).
       \ENDIF
      
       \STATE $r \leftarrow $ extract\_min(${\cal H}$)
       \STATE t $\leftarrow$ next\_free\_interval(free\_intervals, t) //{\em if there is no more free interval of size $\tau$, the algorithm fails}
       \STATE $w_i \leftarrow$ t - eligible\_time[$r_i$]
       \STATE update(t,free\_ intervals)
       \STATE t $\leftarrow$ t + $\tau$
       \FORALL{routes $r_i$ with  eligible\_time[$r_i$] $\leq$ t}
 \STATE insert(${\cal H}$,$r_i$).
       \ENDFOR
       \ENDWHILE
     \end{algorithmic}
     \end{algorithm}


    The complexity of Algorithm~\ref{alg:GD} is in $O(n\log(n))$, using the proper data structures.
    The set of eligible routes must be maintained in a binary heap
    to be able to find the one with smallest deadline in time $O(\log(n))$. 
    To deal with the possible collisions, one maintains a list of the intervals
    of time during which a message can be sent on the arc $(c_t,c_s)$. Each time the offset of a 
    route is fixed an interval is split into at most two intervals in constant time. 
    Since the algorithm goes over the elements of this list at most twice when doing an insertion
    or looking for the next free interval, the time needed to maintain it is $O(n)$. 
  
     \subsection{Earliest deadline scheduling}\label{sec:braheuristic}
     
     
     The problem \bra is the same as the following scheduling problem if we forget the periodicity. Given a set of jobs with \emph{release times} and  \emph{deadlines}, schedule all jobs on a single processor, that is choose the time at which they are computed, so that no two jobs are scheduled at the same time. A job is always scheduled after its release time and it must be finished before its deadline. Let us call $n$ the number of jobs, the problem can be solved in time $O(n^2\log(n))$~\cite{simons1978fast} when all jobs have the same running time and it gives a solution which minimizes the time at which the last job is scheduled. On the other hand if the running times are different the problem is $\NP$-complete~\cite{lenstra1977complexity}. 
     The  polynomial time algorithm  which solves this scheduling problem is similar to the greedy algorithm presented in the previous section. However, when it fails because a job finishes after its deadline, it changes the schedule of the last messages to find a possible schedule for the problematic job. The change in the scheduling is so that the algorithm cannot fail on the same job a second time except if there are no solutions, which proves that the algorithm is in polynomial time.
     
     The problem \bra is reduced to this scheduling problem. The backward routes are the jobs, the size of a message is the running time of a job, the deadline of a route is the deadline of the corresponding job and the smallest time at which it is eligible is the release time. Let us call {\bf Minimal Latency Scheduling (MLS)} the algorithm which transform \bra into the described scheduling problem to solve it in polynomial time.
     
     Let us denote by $y_i$ the time at which the message of the route $r_{\rho(i)}$ cross the node $c_t$,
     that is $y_i = m_{\rho(i)} + \lambda(i)$. Let us denote by $y_{min}$ and $y_{max}$ the smallest and largest value of the $y_i$s. When MLS finds an assignment $m$, it always satisfies $PT(r) < d(r)$ for all $r$. If $y_{max}- y_{min} \leq P -\tau $, then all messages cross $c_t$ in the same period and 
     the scheduling algorithm guarantes that there are no collision. However, if $y_{max}- y_{min} > P -\tau $, then we must take into account the periodicity by computing the $y_i$ modulo $P$ and the solution we obtain by PMLS may have a collision. Since the scheduling algorithm minimizes $y_{max}- y_{min}$, it may work sometimes (as shown in Section~\ref{sec:resultsPALL}), but not for all instances. 
     
     
     We now present a variant of the previous algorithm that we call {\bf Periodic Minimal Latency Scheduling (PMLS)}. The aim is to deal with the periodicity, by modifiying the instance (without changing the assignments) so that the chance of finding a solution with $y_{max}- y_{min} \leq P -\tau $ are larger.  Remark that if an instance has a satisfying assignment, we can always guarantee that one route has a waiting time zero in a satisfying assignment. Hence, w.l.o.g., we will fix a route as the first one and assume it has waiting zero.
     
     Algorithm PMLS runs, for each route $r$, the algorithm MLS on an instance defined as follows. 
     Let $rt$ be the release time of $r$, we subtract it to all release time and deadline.
     Therefore the release time of $r$ is zero and the time at which the message of $r$ crosses $c_t$ is also set to zero, hence its waiting time is zero.  We then modify the instance so that all release times are in $[0,P-\tau]$: Each release time $rt$ is replaced by $rt \mod P$ and $rt - (rt \mod P)$ is subtracted to the corresponding deadline. 
     Furthermore, if a release time of a route $r_i$ is between $  P-\tau$ and $P$, we set it to $0$ and $d(i) = d(i) - P$. 
     
     The deadline of each backward route is set to the minimum of their deadline and $P - \tau$. Because of this modification of deadlines, if MLS finds a solution for an instance, we have $y_{max}- y_{min} \leq P -\tau $, hence it is a $(P,\tau)$ periodic assignment.  The algorithm PMLS finds periodic assignments more often than MLS, because if MLS finds a solution with first route $r$ and such that $y_{max} - y_{min} \leq P -\tau$, then this solution is found by PMLS when it selects $r$ as the first route. Since MLS is used at most $n$ times, the complexity of PMLS is in $O(n^3\log(n))$. Note that PMLS is a heuristic and may fail to find assignments when they have some $y_i$ larger than $P - \tau$.
     
%     \begin{algorithm}[H]
%     \caption{ Minimized Scheduling Periodic (MSP)}
%     \begin{algorithmic}
%     \REQUIRE A routed network $(G,{\cal R})$,a period $P$, packet size $\tau$, $ T_{max}$, the offsets $m_i$
%     \ENSURE $(P-\tau)-$periodic assignment of $(G,{\cal R})$, if it exists
%   
%     \FORALL{route $r_{t_i}$}
%     \STATE  $w_i \leftarrow 0$
%     \STATE period-end $\leftarrow m_{s_i} + \lambda(r_{s_i}) + t(c_t,r_{t_i}) + P$
%     \FORALL{route $r_{t_j}$}
%     \STATE deadline-route$ \leftarrow m_{s_j} + T_{max}-t(c_s,r_{s_j})$
%     \STATE $deadline \leftarrow$ min(deadline-route,period-end)
%     \ENDFOR
%     
%     \STATE Call (MS)
% 
%     
%     \ENDFOR
% 
%     \STATE return the best $(P,\tau)$-periodic assignment, or FAILURE
% 
%     \end{algorithmic}
%     \end{algorithm}

\subsection{FPT algorithms for \bra and \pall}

As a warm-up, we give a simple FPT algorithm for \bra which is practical,
and then we build on it to give a more complicated FPT algorithm for \pall. Unfortunately, the dependency on $n$ the number of routes in the second algorithm is yet too large to be useful in practice. 

\begin{theorem}\label{th:braFPT}
$\bra \in \FPT$ when parametrized by the number of routes.
\end{theorem}
\begin{proof}
 Consider an instance of \bra, which can be characterized by a release time and a deadline for each route. W.l.o.g. say that the first backward route has release time $0$. 
As for PMLS, we change the release times and deadlines such that all release times are less than $P - \tau$. If there is an assignment such that the messages of all routes goes through $c_t$ before $P-\tau$, then the periodicity does not come into play for this assignment and the algorithm MLS will find it as explained in Section~\ref{sec:braheuristic}.

 Now, remark that if there is a periodic assignment for an instance, then there is a periodic assignment satisfying for all $i$, $y_i \leq 2P - \tau$. Indeed, if there is a $i$ such that $y_i > 2P - \tau$ in
a periodic assignment, then setting $y_i = y_i - P$ cannot create a collision and improve the 
process time of $r_i$ by $P$. Moreover $y_i - P > P- \tau$, hence the it is a valid assignment, that is the route $r_i$ sends its message after its release time. 

From a periodic assignment satisfying that for all $i$, $y_i \leq 2P - \tau$, we define 
a new instance whose periodic assignments are a subset of the periodic assignments of the original instance. Moreover, one of the periodic assignments of the new instance satisfies for all $i$, $y_i \leq P - \tau$ and will thus be found by MLS.
Let $S$ be the set of routes $r_i$ such that  $y_i \in[P-\tau, 2P - \tau]$. The new instance is defined by setting the release time of the routes in $S$ to $0$ and by subtracting $P$ to their deadlines. Then the considered periodic assignment is a solution of the new instance with all $y_i \leq P -\tau$. Moreover any solution of the new instance is a solution of the original one, since we have made the constraints harder.   

The FTP algorithm is the following: for each subset $S$ of routes, remove $P$ to the release time and to the deadline of each route in $S$ and run MLS on the new instance. If there is an assignment, then we have proved that there is an $S$ such that the modified instance has a solution with all messages going through the central arc between $0$ and $P - \tau$, a solution that MLS will find.
\end{proof}

The algorithm of Theorem~\ref{th:braFPT} has a complexity of $O(2^nn^2\log(n))$. Moreover, for each backward route to be scheduled between $P$ and $2P-\tau$, it must have a deadline larger than $P + \tau$ since between $P$ and $P + \tau$ the first message goes through the central arc. Often, only a small fraction of the routes have a deadline larger than $P + \tau$, say $k$ of them and we explore only $2^k << 2^n$ cases. Let us call this algorithm {\bf FPT-PMLS} for the rest of the article.


\begin{theorem}\label{th:pallFPT}
$\pall \in \FPT$ when parameterized by the number of routes.
\end{theorem}
\begin{proof}
 Consider an instance of \pall which has a solution. We now characterize such a solution by a set of necessary and sufficient linear equations and inequations it must satisfy. 
 For simplicity, we consider $x_i$ the time at which a message goes through $c_t$ on the forward route $r_i$ and $y_i$ the time at which it goes through $c_t$ on the backward route $r_{\rho(i)}$.
 Choosing values for $x_i$ and $y_i$ is equivalent to choosing the offsets $m_i$ and $m_{\rho(i)}$.
 
 The values $x_i$ and $y_i$ satisfies the following inequation: $y_i \geq x_i + 2\lambda(r_i)$.
We may assume that the first route has release time and waiting time zero, 
that is $x_0 = y_0 = 0$. We can also guarantee that all $x_i$ are less than $P-\tau$ if we modify
the release times and deadlines without changing the possible assignments. As in Theorem~\ref{th:braFPT}, we have all $y_i < 2P - \tau$,
and  when $y_i \geq P - \tau$ we replace $y_i \geq x_i + 2\lambda(r_i) $ by $y_i \geq x_i + 2\lambda(r_i) - P$ and we replace the deadline $d(r_i)$ by $d(r_i) -P$. In that way we guarantee that all $y_i$ are less than $P-\tau$.  
 
 Since all $x_i$ and $y_i$ are in $[P-\tau]$, taking the values of $x_i$ and $y_i$ modulo $P$
 does not change anything, which makes easy to express the absence of collisions between routes.
 To express that there are no collision between forward routes, the following equations must be  satisfied: for all $i$, $x_i + \tau \leq x_{i+1}$. We assume that the routes are here indexed such that the $x_i$ are in ascending order.
 Let $\sigma : [n] \rightarrow [n]$ be the permutation such that the $y_{\sigma(i)}$ are in ascending order.
 To express that there are no collision between backward routes, the following equations must be  satisfied: for all $i$, $y_{\sigma(i)} + \tau \leq y_{\sigma(i+1)}$. Finally, the deadline of each route must be respected, that is for each $i$, $y_i \leq d(r_i)$. 

 Let $S$ be the system of all the previous equations, by construction of $S$, any of its solutions seen as a choice of offsets 
is an assignment since there are no collisions in the forward and backward period between $0$ and $P$ and we have guaranteed that 
all routes meet their deadlines. However, the solutions of $S$ may have rational values, while offsets must be integers. 
Remark that $x +e_1 \leq y + e_2$ implies $\lceil x \rceil +e_1 < \lceil y \rceil + e_2$ when $e_1$ and $e_2$ are integers.
Therefore, since all the inequations and equations of $S$ have this form, if we take the upper floor of the values of a solution of $S$, it is still a solution of $S$ with \emph{integer} values. As a consequence, any rounded solution of $S$ yields a solution of the considered instance of \pall.

Now remark that the construction of $S$ depends on the choice of the order of the forward routes, the order of the backward routes, and on the choice of the backward routes where $P$ has been subtracted from the offset. Hence to solve \pall, we must solve $2^n(n!)^2$ systems with $2n$ variables and a bitsize of the same order than the instance of \pall. Since solving each system can be done in polynomial time it proves the theorem.
\end{proof}


    \subsection{Experimental evaluation}
    \label{sec:resultsPALL}
    
    We set the number of routes to $8$ to make comparisons with the results of Section~\ref{sec:exp_PAZL} easier. 
    We draw uniformly the weights of the arcs between $0$ and $20,000$. To simplify the experiments, 
    we use \emph{the same deadline} for all routes. We define the {\bf margin} as the difference between the deadline and twice the longest route. The margin represents the \emph{logical latency} imposed by the communication process without taking into account the physical length of the network which cannot be changed. For a given star routed network, setting the margin or the deadline is the same, but when comparing different star routed networks with different size of routes, the margin is more relevant than the deadline.
    In our experiments the margin ranges from  $0$ to $3,000$.
   We look at two different regimes, a medium load of $80\%$ and a high load of $95\%$.
   Considering smaller load is not relevant since we can solve the problem without waiting times as shown in Section~\ref{sec:exp_PAZL}. 
   
   We first try to understand what is the best choice of order for the first stage of the algorithm which is followed by the GD algorithm in this experiment. In Figure~\ref{fig:success80} and \ref{fig:success95}, we represent the success rate of the seven kind of orders with regards to the margin. The value is an average computed over $10,000$ random star routed networks. For RO, RORS and ROBS, we draw $1000$ random orders and count it as a success as soon as there is a solution for one order. Each random order drawn is tested on the three policies with random orders, if a solution has not been found yet with this policy.

\begin{figure}[h] 
  \centering
          \includegraphics[width=0.5\textwidth]{departs_gp_25000.pdf}
      \caption{Success rate of different sending orders, $80\%$ load.}
           \label{fig:success80}
     \end{figure}
     
\begin{figure}[h] 
  \centering
    \includegraphics[width=0.5\textwidth]{departs_gp_21000.pdf}
      \caption{Success rate of different sending orders, $95\%$ load.}
      \label{fig:success95}
          \end{figure}

     According to our experiments, sending the messages from the shortest to the longest route or arc does not work well. It corresponds to the policy of Proposition~\ref{prop:SL} which we already know to be bad for \pazl when the routes are long as in this experiment. Sending from the longest to the shortest route or arc works better and it seems that sorting the routes according to the length of the last arc rather than the route is better, at least in a loaded network. 
     
     Trying random orders is much better than our naive choice of order.
     With a load of $95\%$, there is a solution with margin $0$ most of the time. Also, the three random order policies seems to have similar performances, but the RO policy gives a bit more solutions than the two others ones, under high load and low margins. This is the reason why in the following experiments on the performances of our algorithms to solve \bra, we will always use the RO policy.  Note that, when disallowing waiting times, there were no instances with an assignment for $95\%$ of load and long routes (see Section~\ref{sec:exp_PAZL}), which justifies the interest of studying \pall rather than \pazl.
     
      We now want to compare the performances of the four different algorithms used in the second stage. Since GD already showed excellent results on mild loads, it is more interesting to focus on the behavior of the algorithms on high load. Moreover, we will use $1,000$ random orders for the first stage as it gives the best results. In Figure~\ref{fig:success21000}, we represent the success rate of the three algorithms with regards to the margin,  computed over $10,000$ random star routed networks and the same parameters as previously.
     
    \begin{figure} [h] 
       \begin{center}
      \includegraphics[width=0.5\textwidth]{retour_21000.pdf}
      \end{center}
      \caption{Success rate of GD, MLS, PMLS and FPT-PMLS, $95\%$ load}
     \label{fig:success21000}
     \end{figure}

     The MLS algorithm performs poorly, worst than GD, PMLS and FPT-PMLS, which shows that \emph{taking into account the periodicity} is fundamental.
     The GD algorithms is close to $100\%$ success rate for margins larger than $1,500$ while the PMLS and FPT-PMLS algorithms find a solution in more than $99\%$ of the experiments, even with a margin $0$. Therefore, for the worst possible constraints on load and margin, there are only a few instances for which we do not find a solution. With a margin of $600$, which corresponds to about $0.03$ms of additional delay with the chosen parameters, we always find a solution. 
     Note that the PMLS and FPT-PMLS algorithm have some very similar performances. In fact, it appears that the FPT-PMLS algorithm have, most of the time, the same success rate than the PMLS algorithm, even with a load of $100\%$ and a margin of $0$ (only $2$ instances of $100,000$ have been found by FPT-PMLS and not by PMLS). Since the improvement of FPT-PMLS is insignificant beside the PMLS performances, we investigate the computation time of the two algorithms.
     Figure~\ref{fig:exec_time} shows the average computation time of the two algorithms during the previous experiment.
     
        \begin{figure} [h] 
       \begin{center}
      \includegraphics[width=0.5\textwidth]{time_exec.pdf}
      \end{center}
      \caption{Computation time of PMLS and FPT-PMLS}
     \label{fig:exec_time}
     \end{figure}

	First, remark that the computation time of the two algorithm decrease until a margin of approximately  $1,000$ slots. Indeed, the more the algorithm fails, the higher the computation time is because the $1,000$ random orders have to be drawn before failing. Moreover, even when both of the two algorithms always succeed, the computation time of FPT-PMLS is about $10$ time higher that the computation time of the PMLS algorithm. Furthermore, when the FPT-PMLS algorithm could be able to find a solution that the PMLS algorithm would not find, i.e. on low margins, the computation time is $14$ time higher for the first algorithm. It is not really worth it since, most of the time, the FPT-PMLS algorithm do not have a better success rate than the PMLS algorithm.
     
    Recall that the random order corresponds to the best of $1,000$ orders drawn uniformly which means that a computation can be up to $1,000$ time slower than for a fixed order. The choice of the number of random orders drawn yields a trade-off between the computation time and the success rate. Up to now, we have chosen the number of random orders to be $1000$ arbitrarily.
    
    We investigate the success rate of our algorithm with regards to the number of random orders drawn, a load of $95\%$ and a margin $0$. The table of Figure~\ref{fig:randomdrawing} presents the average success rate for each number of sending orders, on $10,000$ instances, for GD and PMLS. Since this experiment is already long on PMLS for $10^{4}$ and $10^{5}$ routes, we do not run it on FPT-PMLS.
         \begin{figure}[h] 
       \begin{center}
   \begin{tabularx}{0.5\textwidth}{|c|X|X|X|X|X|X|}
    \hline
    \# orders& $1$ & $10$ & $100$& $1,000$& $10^{4}$&$10^{5}$\\
    \hline
    GD & $0.6$ &$7.1$&$33.4$&$76.4$&$90.0$&$90.0$\\
    \hline
  PMLS & $38.9$ &$83.0$&$95.3$&$97.2$&$97.5$&$97.7$\\
    \hline
      \end{tabularx}
      \end{center}
   \caption{Impact of the number of random sending orders}
        \label{fig:randomdrawing}
     \end{figure}
%      \todo{ajouter l'algo FPT qui ameliore PMLS et dire quelque chose sur le temps de calcul pour voir jusqu'a quand c'est faisable}
     
     
First, remark that we can improve our previous results by taking $10,000$ random orders,
instead of $1,000$. The number of different orders is $7!= 5,040$ since we have $8$ routes and the solutions are invariant up to a circular permutation of the order. Therefore instead of doing $10,000$ random draws we could test every possible order in less time. However the computation time of this method would scale badly with $n$. On the other hand, remark that the success rate of PMLS is already high for $100$ random orders, which means it will work even better than the other methods when $n$ is larger and that the number of random orders drawn becomes critical.
     
     Now that we have found the best amongst the algorithms solving \pall, we need to compare its performances against the actual way to manage the messages in a network:  statistical multiplexing, with a FIFO buffer in each node of the network to resolve collisions. The time at which the messages are sent in the network is not computed as in our approach, thus we fix the offsets of each route to some random value.
     Even if this policy seems to work in practice when the network is not too loaded, it does not give any guarantee on the latency. Remark that the process is not periodic, therefore we must measure the process time of each route over several periods if we want to compute its maximum. We choose to simulate it for $1,000$ periods and we have observed that the process time usually stabilizes after $10$ periods. The margin is defined as the maximum process time, computed as explained, minus twice the size of the longest route. 
	    
     In Figure~\ref{fig:sto}, we represent the probability of success for 
     statistical multiplexing and PMLS for different margins. The success rates are computed from $10,000$ star routed networks for each margin, drawn with the same parameters as before. We represent the distribution under high and light load for statistical multiplexing and under high load only for PMLS since under light load the margin is always $0$. 
     

    \begin{figure}
       \begin{center}
      \includegraphics[width = 0.45\textwidth]{stochastic.pdf}
       %\input{figures/stochastic}
      \end{center}
      \caption{Probability of success of statistical multiplexing and PMLS for several margins}
      \label{fig:sto}   
     \end{figure}    
     
     The experiment clearly shows that statistical multiplexing does not ensure a minimal latency. 
     The latency is extremely high when the load is high, with a margin of about $10,000$ for the worst $10\%$ which corresponds to half the period, that is $0.5$ms. Even when the network is lightly loaded, $20\%$ of the instances have a margin of more than $2,000$. On the other hand, PMLS finds an assignment with margin $0$ in a highly loaded network $99\%$ of the time! 
     For each $1,000$ slots of latency we save from the periodic process, we are able to lengthen the routes of $10$km, which has a huge economical impact. We feel that it strongly justifies the use of a deterministic sending scheme for latency critical applications such as our C-RAN motivating problem.     
     
 \section{Conclusion}
In this paper, we proposed two deterministic methods to establish a low latency periodic communication between BBUs and RRHs in a star shaped fronthaul network. The first method uses no buffering and has no latency overhead. It works when the routes are short (Longest-Shortest policy) or when the load is less than $80\%$ (Exhaustive search of compact assignments).  
When the load is higher, buffering is allowed in the BBUs and we propose the algorithm PMLS which  finds a deterministic communication scheme with almost no additional latency.
% 
% We plan to study other commons fronthaul topologies such as caterpillars, trees or ring; the latter being different since 
% the forward and backward routes are not symmetric. For other applications, it could be interesting to optimize the average latency of the routes rather than the worst latency, a problem which may be solved using linear optimization.   

   
   We plan to generalize our study of the \pall problem to other common fronthaul topologies,
   such as caterpillar, trees, cycles or bounded treewidth graphs. The cycles in particular are 
   different since their forward and backward routes are not symmetric. 
   We would like to design an FPT algorithm for \pall which is as efficient as the one for \pazl 
   and prove that both problems are $\NP$-hard.

   We could also study variations of our problem. Instead of minimizing the maximum process time, we could try to minimize the average process time, a linear objective which could make linear programming useful. We could allow preemption, that is the messages are allowed to be cut into pieces, which would certainly change the complexity of the problem.  Instead of periodic communication we could try to organize communications with pseudo-periodic schemes or even a temporal law. Moreover we could allow a bounded message loss.
   Finally, the routes may not be fixed but chosen in the graph to minimize the maximum process time, which would make the problem even more difficult (maybe $\Pi_2$-complete instead of $\NP$-complete). 

  
 \paragraph*{Acknowledgments} 
 We thanks Olivier Marc and Brice Leclerc who have introduced us to the problem.
 We also thank Christian Cad\'er\'e and David Auger for friendly discussions on the subject and insightful remarks. This work is partially supported by the french ANR project N-GREEN.

\bibliographystyle{ieeetr}
\bibliography{Sources}

\end{document}
