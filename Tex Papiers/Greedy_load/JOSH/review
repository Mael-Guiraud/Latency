
COMMENTS FOR THE AUTHOR:

Reviewer #1: The paper under review provides an innovative approach to scheduling periodic messages through two contention points in a network, notably inspired by the Cloud-RAN architecture for mobile networks. The manuscript's key strengths lie in the comprehensive problem definition, supported by a well-motivated, realistic application scenario, rigorous methods, and convincing results. The use of mathematical tools like graph theory, combinatorics, and probability to design and analyze the algorithms stands out, along with the clarity and organization of the paper.

However, some aspects of the work could be improved. A comparison with the state-of-the-art (SOTA) methods or heuristics for similar problems is noticeably absent, and this omission may undermine the significance of the results. Additionally, the lack of discussion regarding the practical challenges of implementing the proposed algorithms and the absence of graphical representation for a clearer understanding are aspects that should be addressed.

On a minor note, certain sections could be rearranged for better coherence, such as moving paragraphs 3 and 4 from the related works to the introduction, relocating Table I to section 6, and adding a contribution part. The use of numerous greedy algorithms in section 3 prompts a question about any improvements proposed in this paper. Concentrating on the novel points for ease of reader comprehension would also be beneficial.

In conclusion, the paper offers valuable insights into the field of scheduling periodic messages and proposes promising polynomial-time algorithms. It has the potential to make a significant impact, but there are areas that warrant attention to fully realize this potential. Exploring other variations of the problem, such as different message sizes or objective functions, might open exciting avenues for further research.


Reviewer #2: this paper studies the problem of reminiscent of coupled-task scheduling and proposes a periodic message assignment algorithm. This paper is with certain contribution. My comments are as follows:

1.      In introduction, the authors should list the contributions and features of the proposed algorithm and mathematic model.
2.      In Fig. 1, the sub-figure of "Datacenter with several BBUs" has low resolution. Please provide clearer figures.
3.      The background of CRAN should be described.
4.      In the experiment, the authors give the experimental results for small messages and for large messages. However, are these experiments really related to the real-world application scenarios? I think the authors should discuss the performance of the proposed algorithm in more real-world application scenarios.
5.      In experiments, what are the experimental results of the proposed compact k-tuples algorithm?
6.      Most of the references are too old! Only two references are after 2021, while most of them are in 1990s? The authors should update the related work and should also modify the Introduction by using more recent work to enhance the motivation and contribution of their work. In fact, there are related works in leading journals like IEEE TEVC and IEEE TCYB that can help to enhance/update the quality of this paper.



Reviewer #3: This paper addresses the problem of finding a periodic sending scheme of these mes-sages without contention nor buffering, where a new model is built and solved by several greedy, deterministic, and probabilistic algorithms. Detailed comments are given below.

1. While the proposed problem is not verified to be P or NP, how can it be solved by any greedy, deterministic, and probabilistic algorithms with polynomial time?

2. As an optimization problem, the self-contrained mathematical definition of the proposed problem should be given in detail.

3. The detailed procedures of the employed algorithms should be given, so that they can be reimplemented by readers.

4. The value of the proposed problem compared with existing ones should be analyzed or verified by experiments.

5. Real-world datasets (instances) should be involved in the experiments.






*********************************************************************************************************************************************************

We thank the reviewers for their remarks on the article. We took into account all remarks on the organization and presentation of the paper, 
hopefully improving its readability. In particular, we have reorganized the introduction, added a contribution section and updated the references therein. We have included a few figures and algorithm environments along the text to help the reader. We have added several discussions into the article to address the remarks of the reviewers. 



Specific answers to questions and suggestions:



TODO: Maël, un dessin pour expliquer les collisions: un dessin avec deux messages avec des offsets qui sont en collision (on peut montrer collision dans la premiere et seconde période + périodique)

Définition Periodic message assignment avec un environnement problème

Dire qu'on va scheduler les compacts pairs comme un seul objet 

Faire un petit paragraphe au début des expériences pour dire à quoi elles servent, ce qu'elles montrent

Trouver ou parler des méthodes classiques pour résoudre des problèmes similaires de scheduling et de pourquoi on ne les explore pas.
(dans related work ?)


Answer to the reviewers:

# Comparison with methods for similar problems. 

Typiquement, mixed integer linear programming -> dire pourquoi pas pertinent et qu'on discute de ça dans le papier. 
Pareil pour beanch and bound. 
En plus, trouver un algo bon en pratique, c'est bien mais ça n'est pas notre objectif principal, qui est plus théorique.

Out of the scope of the paper, we are looking for polynomial time algorithms which proves that there is always a solution when the load is low enough. 
The classical methods for similar would give heuristic or exponential time algorithms which may solve the problem but would not give any theoritical results on the existence of solutions for small load. 

Not an optimization problem + Mixed integer linear programming does not seem a good fit: because of the periodicity, the constraints rather than being expressed as a few inequalities as in classical scheduling problems, would be here modeled as a large number of inequalities ...
Could be solved by a SAT solver, but quite large because each slot corresponds to a variable and   

# References. 

The application domain of CRAN is quite new and active, and we have put a few references to the most recent works in this domain. 
To our knowledge, there is no theoretical work on the same kind of periodic model, recent or old. Most relevant works for similar scheduling problems are from the 1990's and 2000's. However, we updated the references with very recent surveys of the domain. 


# (Reviewer 1 and 3) The algorithms of the article and how they are implemented. 

All algorithms are given formally in the article with enough details to be implementable. Moreover, they have been coded in C for our experiments and the  code is available on the following webpage. 

Dire qu'on a mis des environnements algo et modifié le texte pour que ça soit le plus clair possible.


Reviewer #3

1. We solve the problem in regim where the load is small, which restricts the set of possible instances. In that case, the problem is not in NP anymore, in fact all instances are positive and the contribution of this article is to show how to find solutions in this case for the largest possible value of the load.

5. There are no real word datasets for our CRAN application. We are working with Bell-Labs on this subject, and our problem and algorithms have been invented to support new products. There are only prototypes of these products, hence there is no real data of how they are used in the field. 

Dire qu'on a essayé des tailles de paquet différentes (typiquement 1 ou grand) et des nombres de paquet qui correspondent à notre cas d'usage de quelques dizaines d'antennes connectées. Par contre, si les délais ont une structure particulière, on pourrait obtenir des résultats différents. Notre cas d'usage du CRAN sans buffer c'est plus les paquets grands, mais pour d'autres usages, typiquement avec des petits buffers de synchro, on peut se ramener facilement au cas de taille 1.


Dire aussi qu'on a donné des explications (dans la section 5) de pourquoi notre modèle simple pouvait capturer des usages plus complexes (avec d'autre tailles de paquet et d'autres topologies et la possibilité d'avoir de la latence).